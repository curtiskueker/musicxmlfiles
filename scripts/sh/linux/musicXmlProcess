#!/bin/bash

process_usage() { echo "$*" >&2; exit 1; }
help() {
  cat <<HELP
Usage: musicXmlProcess [OPTIONS] SCRIPT_NAME [OUTPUT_DIRECTORY] INPUT_LIST

Executes bulk runs of a script by calling SCRIPT_NAME for each item in an INPUT_LIST.

An OUTPUT_DIRECTORY argument is required for some values of SCRIPT_NAME.

SCRIPT_NAME: One of the following values:

musicXmlValidate
musicXmlCompress
musicXml2Db
musicXml2Ly
musicXml2Pdf
db2MusicXml
db2Ly
db2Pdf
ly2Pdf

OUTPUT_DIRECTORY:  Required for SCRIPT_NAME values that generate output:

Output filenames:

musicXmlCompress:  Output filenames are same as the MusicXML input filenames, but with a .mxl extension
musicXml2Ly:  Output filenames are same as the MusicXML input filenames, but with a .ly extension
musicXml2Pdf:  Output filenames are same as the MusicXML input filenames, but with a .pdf extension
db2MusicXml:  Output filenames are the Score IDs or score names passed as arguments, with underscores replacing spaces, and a .xml extension
db2Ly:  Output filenames are the Score IDs or score names passed as arguments, with underscores replacing spaces, and a .ly extension
db2Pdf:  Output filenames are the Score IDs or score names passed as arguments, with underscores replacing spaces, and a .pdf extension
ly2Pdf:  Output filenames are same as the LilyPond input filenames, but with a .pdf extension

INPUT_LIST:
For scripts that take file input (scripts musicXml* and ly2Pdf), the input list is a space-separated list of file names and directories, including wildcards.

Examples:

Input list examples:

Single file input: files/jsbach/Invention_1.xml

A list of files matching a pattern: files/jsbach/Invention_*.xml

All files in a directory: files/jsbach/*

Database record input (scripts db2*): the input list is a space-separated list of score names, score IDs, and score ID ranges.

Comma-separated score name lists are not processed as lists of score names because score names may contain commas.

Score ID lists and ranges can be comma-separated lists of ID numbers with dashes indicating score ranges.

Score ID range example: 3,18-20,39 will execute score IDs 3, 18, 19, 20, and 39.

musicXmlProcess script call examples:

Output Score ID database records 1 to 50 as MusicXML to directory files/output:

musicXmlProcess db2MusicXml files/output 1-50

Output database records with score names "movement 1", "movement 2", "movement 3", and "movement 4" as LilyPond files to directory files/output:

musicXmlProcess db2Ly files/output "movement 1" "movement 2" "movement 3" "movement 4"

Load all MusicXML files in directory files/jsbach into the database with verbose output:

musicXmlProcess -v musicXml2Db files/jsbach/*

Options:
  -v, --verbose		displays processing output
HELP
exit 0
}
version() { echo "1.0"; }
get_input_sublist() {
  INPUT_SUBLIST=()
  local IFS=,
  local INPUT_SUBITEM=($INPUT_ITEM)
  for SUBITEM_VALUE in "${INPUT_SUBITEM[@]}"; do
    if [[ $SUBITEM_VALUE =~ [\-] ]]
      then
        local IFS=-
        local RANGE_ITEMS=($SUBITEM_VALUE)
        if [[ ${#RANGE_ITEMS[@]} -ne 2 ]] ; then process_usage "Invalid Score ID range $SUBITEM_VALUE"; fi
        BEGIN_RANGE=${RANGE_ITEMS[0]}
        END_RANGE=${RANGE_ITEMS[1]}
        if [[ $BEGIN_RANGE -gt $END_RANGE ]] ; then process_usage "Invalid Score ID range $SUBITEM_VALUE"; fi
        for (( RANGE_ITEM=$BEGIN_RANGE; RANGE_ITEM<=$END_RANGE; RANGE_ITEM++ )) ; do INPUT_SUBLIST+=($RANGE_ITEM) ; done
      else
        INPUT_SUBLIST+=($SUBITEM_VALUE)
    fi
  done
}

SCRIPT_DIRECTORY=scripts/sh
OUTPUT_DIRECTORY=''
VERBOSE=''

while getopts 'hv-:' flag; do
  if [ "$flag" = "-" ]; then
    flag="${OPTARG%%=*}"
    OPTARG="${OPTARG#$flag}"
    OPTARG="${OPTARG#=}"
  fi
  case "${flag}" in
    h|help) help ;;
    v|verbose) VERBOSE="-v" ;;
    version) version ; exit 0 ;;
    ??*) process_usage "Unrecognized option --$flag" ;;
    ?) exit 1 ;;
  esac
done
shift $(expr $OPTIND - 1)
SCRIPT_NAME=$1; shift

case $SCRIPT_NAME in
  musicXmlValidate|musicXmlCompress|musicXml2Db|musicXml2Ly|musicXml2Pdf|db2MusicXml|db2Ly|db2Pdf|ly2Pdf) ;;
  *) process_usage "Usage: musicXmlProcess SCRIPT_NAME [OUTPUT_DIRECTORY] INPUT_LIST" ;;
esac

if [ $SCRIPT_NAME != musicXml2Db ] && [ $SCRIPT_NAME != musicXmlValidate ]
  then
    OUTPUT_DIRECTORY=$1; shift
    if [ -z $OUTPUT_DIRECTORY ] ; then process_usage "Output directory not found"; fi
    if [ ! -d $OUTPUT_DIRECTORY ]
      then
        echo process_usage "$OUTPUT_DIRECTORY is not a directory"
        exit 1;
    fi
fi

if [[ -p /dev/stdin ]]
    then INPUT_LIST=$(cat -)
    else INPUT_LIST=("$@")
fi

if [[ ${#INPUT_LIST[@]} -eq 0 ]] ; then process_usage "Invalid input list"; fi

for INPUT_ITEM in "${INPUT_LIST[@]}" ; do
    echo "Executing:" $SCRIPT_NAME $INPUT_ITEM
    case $SCRIPT_NAME in musicXmlValidate|musicXmlCompress|musicXml2Db|musicXml2Ly|musicXml2Pdf|ly2Pdf) FILE_LIST=$(ls -d $INPUT_ITEM) ;; esac
    case $SCRIPT_NAME in
      musicXmlValidate)
        for FILE_INPUT_ITEM in $FILE_LIST ; do ${SCRIPT_DIRECTORY}/$SCRIPT_NAME "$FILE_INPUT_ITEM"; done ;;
      musicXmlCompress)
        for FILE_INPUT_ITEM in $FILE_LIST ; do
          LOCALFILENAME=$(basename ${FILE_INPUT_ITEM})
          OUTPUT_FILE=${OUTPUT_DIRECTORY}/${LOCALFILENAME%.*}
          ${SCRIPT_DIRECTORY}/$SCRIPT_NAME "$FILE_INPUT_ITEM" $OUTPUT_FILE
        done
        ;;
      musicXml2Db|musicXml2Ly|musicXml2Pdf|ly2Pdf)
        for FILE_INPUT_ITEM in $FILE_LIST ; do
          LOCALFILENAME=$(basename ${FILE_INPUT_ITEM})
          OUTPUT_FILE=${OUTPUT_DIRECTORY}/${LOCALFILENAME%.*}
          ${SCRIPT_DIRECTORY}/$SCRIPT_NAME $VERBOSE "$FILE_INPUT_ITEM" $OUTPUT_FILE
        done
        ;;
      db2MusicXml|db2Ly|db2Pdf)
        if [[ $INPUT_ITEM =~ ^[[:digit:],\-]+$ ]]
          then
            get_input_sublist
            for INPUT_SUBLIST_ITEM in "${INPUT_SUBLIST[@]}" ; do
              OUTPUT_FILE=${OUTPUT_DIRECTORY}/${INPUT_SUBLIST_ITEM}
              ${SCRIPT_DIRECTORY}/$SCRIPT_NAME $VERBOSE $INPUT_SUBLIST_ITEM $OUTPUT_FILE
            done
          else
            OUTPUT_FILE=${OUTPUT_DIRECTORY}/${INPUT_ITEM// /_}
            ${SCRIPT_DIRECTORY}/$SCRIPT_NAME $VERBOSE "$INPUT_ITEM" $OUTPUT_FILE
        fi
        ;;
      *) exit 1 ;;
    esac
done

exit 0;

